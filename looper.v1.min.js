// looper.js  (serve as application/javascript)
// Edit only the config below:

export const config = {
    // For HTML5 <video> on any page (leave 'video' or set '#myVideo', '.player video', etc.)
    selector: 'video',
  
    // Start/end pairs in SECONDS (e.g., [[1,3], [4,6], [10,12]])
    segments: [
      [1, 3],
      [4, 6],
      [10, 12],
    ],
  
    // If no matching <video>, try YouTube iframe on watch pages:
    ytSelector: 'ytd-player iframe, iframe[src*="youtube.com/embed"]',
  
    // Auto-run when the file loads (bookmarklet can be just an import)
    autorun: true,
  };
  
  // ------------------ Engine (no need to edit below) ------------------
  
  export function run(override = {}) {
    const cfg = { ...config, ...override };
    const { selector, segments, ytSelector } = cfg;
  
    if (!Array.isArray(segments) || !segments.length) {
      console.warn('[looper] No segments configured');
      return;
    }
  
    // --- HTML5 <video> case ---
    const el = selector ? document.querySelector(selector) : null;
    if (el && el.nodeName === 'VIDEO') {
      loopHtml5Video(el, segments);
      return;
    }
  
    // --- YouTube iframe case ---
    const iframe = document.querySelector(ytSelector);
    if (iframe) {
      loopYouTubeIframe(iframe, segments);
      return;
    }
  
    console.warn('[looper] No <video> element or YouTube iframe found for selector:', selector, 'yt:', ytSelector);
  }
  
  function loopHtml5Video(video, segments) {
    let i = 0;
    // Jump to first segment and play
    video.currentTime = segments[0][0];
    video.play?.().catch(() => {});
  
    // Loop inside current segment; when passing end -> next segment
    const onTime = () => {
      const [, end] = segments[i];
      if (video.currentTime >= end - 0.03) {
        i = (i + 1) % segments.length;
        video.currentTime = segments[i][0];
        video.play?.().catch(() => {});
      }
    };
    video.addEventListener('timeupdate', onTime, { passive: true });
  }
  
  function loopYouTubeIframe(iframe, segments) {
    let i = 0;
    let playing = false;
  
    const post = (func, args = []) => {
      iframe.contentWindow?.postMessage(
        JSON.stringify({ event: 'command', func, args }),
        '*'
      );
    };
  
    // Listen to progress + state updates from the YT player
    const onMessage = (e) => {
      try {
        const d = typeof e.data === 'string' ? JSON.parse(e.data) : e.data;
        // playerState: 1 = playing
        if (d?.info?.playerState != null) {
          playing = d.info.playerState === 1;
        }
        // currentTime update
        if (d?.info?.currentTime != null && playing) {
          const t = d.info.currentTime;
          const [, end] = segments[i];
          if (t >= end - 0.05) {
            i = (i + 1) % segments.length;
            post('seekTo', [segments[i][0], true]);
            post('playVideo');
          }
        }
      } catch { /* ignore cross-noise */ }
    };
  
    window.addEventListener('message', onMessage);
    post('addEventListener', ['onStateChange']);
    post('addEventListener', ['onVideoProgress']);
  
    // Kick off at first segment
    post('seekTo', [segments[0][0], true]);
    post('playVideo');
  }
  
  // Auto-run if configured
  if (config.autorun) {
    try { run(); } catch (e) { console.error('[looper] autorun error', e); }
  }
  